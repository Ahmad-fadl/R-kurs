
#' Generate a Single Training Vector
#' @description This function generates a single training vector as specified in "Beispiel 10.23" in reference "Richter19"
#' @return returns a single training vector
#' @references Richter, S. (2019). Statistisches und maschinelles Lernen. Springer Spektrum.
# #' @example generate_training_vector()
generate_training_vector <- function () {
  R <- function(z) {
    Delta <- stats::runif(1,-0.1, 0.1)
    if (z == 1L) {
      return(Delta + .3)
    } else {
      stopifnot("z should be either 1 or 2" = z == 2L)
      return(Delta + 1)
    }
  }

  Z <- sample.int(2, size = 1)
  U <- stats::runif(1, 0, 2 * pi)
  X_1 <- R(Z) * c(cos(U), sin(U))

  return(X_1)
}

#' Generate Training Data.
#' @description This function generates training data as specified in "Beispiel 10.23" in reference "Richter19". It is meant for testing purposes.
#' @param n integer; the number of vectors in the returned training data.
#' @return returns a matrix with two rows and \code{n} columns; each column is a training vector.
# #' @example generate_training_data(10)
generate_training_data <- function (n) {
  replicate(n, generate_training_vector());
}

#' Generate a Cluster of Two Dimensional Vectors
#' @description Generates a cluster of two dimensional vectors. The number of vectors and the center of the cluster may be specified via the function's arguments.
#'
#' @param n integer; number of vectors that comprise the returned cluster
#' @param center vector; vector of two elements specifying thw x,y coordinates of the center point
#'
#' @return Returns a matrix with two rows and n columns containing the generated cluster of two dimensional vectors as column-vectors.
#' @export
#'
#' @examples
#' aCluster <- generate_2d_cluster(100);
#' anotherCluster <- generate_2d_cluster(200, center=c(3,2));
generate_2d_cluster <- function (n, center=c(0,0)) {
  generate_vector <- function (offsetX=0, offsetY=0) {
    U <- stats::runif(1, 0, 2 * pi)
    scale <- stats::rnorm(1, .5, .5)
    X_1 <- scale * c(cos(U), sin(U))

    X_1[1] <- X_1[1] + offsetX
    X_1[2] <- X_1[2] + offsetY

    return(X_1)
  }
  replicate(n, generate_vector(center[1], center[2]));
}

plot_clustered_2d_data <- function(data, point_size=.5) {
  stopifnot("The passed data needs to have the \"cluster\" set" =  "cluster" %in% names(attributes(data)));
  stopifnot("Tha passed data is not two dimensional" = nrow(data) >= 2);
  if (nrow(data) > 2) {
    warning("The passed data has more than two dimensions. Only the first two dimensions are used for plotting!");
  }

  numVectors <- ncol(data);
  clusters <- unique(attr(data, "cluster"));
  clusters <- clusters[!(clusters < 0)]
  numClusters <- length(clusters);

  col_gen <- get_color_generator();

  plot(data[1,], data[2,], xlab="x", ylab="y", pch=1, cex=point_size)



  noiseIdx <- attr(data, "cluster") < 0;
  graphics::points(data[1, noiseIdx], data[2, noiseIdx], col="black", pch=20, cex=point_size);

  legendlabels <- c("Noise")
  legendcolors <- c("black")

  for (i in clusters) {
    clusterIdx <- attr(data, "cluster") == i;
    clusterX <- data[1, clusterIdx];
    clusterY <- data[2, clusterIdx];

    cur_col <- col_gen();

    graphics::points(clusterX, clusterY, col=cur_col, pch=20, cex=point_size);

    legendlabels <- c(legendlabels, paste("Cluster", i));
    legendcolors <- c(legendcolors, cur_col);
  }

  graphics::legend("topright", legend=legendlabels, fill = legendcolors, col=legendcolors, cex=1);
}

get_color_generator <- function () {
  # "Dark2" color palette generated by the RColorBrewer package.
  palette <- c("#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
  cnt <- 0

  function () {
    cnt <<- cnt + 1;
    palette[(cnt %% 8) + 1];
  }
}
